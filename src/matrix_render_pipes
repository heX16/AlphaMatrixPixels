#pragma once

#include "matrix_render.hpp"
#include "matrix_types.hpp"

namespace amp {

// Base class for effects that use a source matrix.
class csRenderMatrixPipeBase : public csRenderMatrixBase {
public:
    static constexpr uint8_t base = csRenderMatrixBase::paramLast;
    static constexpr uint8_t paramMatrixSource = base + 1;
    static constexpr uint8_t paramRectSource = base + 2;
    static constexpr uint8_t paramLast = paramRectSource;

    // Source matrix pointer (nullptr means no source).
    csMatrixPixels* matrixSource = nullptr;

    // Source rectangle (defines area to copy from source matrix).
    csRect rectSource;

    uint8_t getParamsCount() const override {
        return paramLast;
    }

    void getParamInfo(uint8_t paramNum, csParamInfo& info) override {
        csRenderMatrixBase::getParamInfo(paramNum, info);
        switch (paramNum) {
            case paramMatrixSource:
                info.type = ParamType::Matrix;
                info.name = "Matrix source";
                info.ptr = &matrixSource;
                info.readOnly = false;
                info.disabled = false;
                break;
            case paramRectSource:
                info.type = ParamType::Rect;
                info.name = "Rect source";
                info.ptr = &rectSource;
                info.readOnly = false;
                info.disabled = false;
                break;
        }
    }

    void paramChanged(uint8_t paramNum) override {
        csRenderMatrixBase::paramChanged(paramNum);
        if (paramNum == paramMatrixSource) {
            if (renderRectAutosize && matrixSource) {
                rectDest = matrixSource->getRect();
            }
        }
    }
};

// Effect: average area by computing average color of source area and filling destination area with it.
// Can average area of the destination matrix itself by setting matrixSource to the same matrix (`matrixSource = matrix`).
class csRenderAverageArea : public csRenderMatrixPipeBase {
public:
    void render(csRandGen& /*rand*/, uint16_t /*currTime*/) const override {
        if (disabled || !matrix || !matrixSource) {
            return;
        }

        // Get average color of source area and fill destination area with it
        const csColorRGBA areaColor = matrixSource->getAreaColor(rectSource);
        matrix->fillArea(rectDest, areaColor);
    }
};
    
// Effect: copy pixels from source matrix to destination matrix with blending.
class csRenderMatrixCopy : public csRenderMatrixPipeBase {
public:

    void render(csRandGen& /*rand*/, uint16_t /*currTime*/) const override {
        if (disabled || !matrix || !matrixSource) {
            return;
        }

        if (rectDest.intersect(rectSource).empty()) {
            return;
        }
        
        // If sizes match, use simple drawMatrix (faster)
        if (rectDest.width == rectSource.width && rectDest.height == rectSource.height) {
            matrix->drawMatrixArea(rectSource, rectDest.x, rectDest.y, *matrixSource);
        } else {
            // Use drawMatrixScale for different sizes
            matrix->drawMatrixScale(rectSource, rectDest, *matrixSource);
        }
    }
};

// Effect: copy pixels by some remap function from source matrix to destination matrix.
class csRenderRemapBase : public csRenderMatrixPipeBase {
public:
    static constexpr uint8_t base = csRenderMatrixPipeBase::paramLast;
    static constexpr uint8_t paramRewrite = base + 1;
    static constexpr uint8_t paramLast = paramRewrite;

    bool rewrite = false;

    uint8_t getParamsCount() const override {
        return paramLast;
    }

    void getParamInfo(uint8_t paramNum, csParamInfo& info) override {
        csRenderMatrixPipeBase::getParamInfo(paramNum, info);
        switch (paramNum) {
            case paramRewrite:
                info.type = ParamType::Bool;
                info.name = "Rewrite";
                info.ptr = &rewrite;
                info.readOnly = false;
                info.disabled = false;
                break;
        }
    }

    virtual bool getPixelRemap(tMatrixPixelsCoord src_x, tMatrixPixelsCoord src_y, tMatrixPixelsCoord & dst_x, tMatrixPixelsCoord & dst_y) const {
        (void)src_x;
        (void)src_y;
        (void)dst_x;
        (void)dst_y;
        return false;
    }

    void render(csRandGen& /*rand*/, uint16_t /*currTime*/) const override {
        if (disabled || !matrix || !matrixSource) {
            return;
        }
    
        // Clip source rectangle to source matrix bounds
        const csRect srcBounds = matrixSource->getRect();
        const csRect srcClipped = rectSource.intersect(srcBounds);
        if (srcClipped.empty()) {
            return;
        }
    
        // Iterate over all pixels in source rectangle
        for (tMatrixPixelsSize y = 0; y < srcClipped.height; ++y) {
            for (tMatrixPixelsSize x = 0; x < srcClipped.width; ++x) {
                const tMatrixPixelsCoord src_x = srcClipped.x + to_coord(x);
                const tMatrixPixelsCoord src_y = srcClipped.y + to_coord(y);
                
                // Get remapped destination coordinates
                tMatrixPixelsCoord dst_x = 0;
                tMatrixPixelsCoord dst_y = 0;
                if (!getPixelRemap(src_x, src_y, dst_x, dst_y)) {
                    continue; // Skip if remap function returns false
                }
    
                // Get source pixel and write to destination with blending
                const csColorRGBA sourcePixel = matrixSource->getPixel(src_x, src_y);
                if (rewrite)
                    matrix->setPixelRewrite(dst_x, dst_y, sourcePixel);
                else
                    matrix->setPixel(dst_x, dst_y, sourcePixel);
            }
        }
    }

};
    
// Effect: convert 2D matrix to linear 1D matrix
//
// linear 1D matrix size:  `height=1`, `width=src.height*src.width`.
// Index starts from 1. (not 0!)
// If `index==0` - skip the pixel.
class csRenderMatrix2DTo1D : public csRenderRemapBase {
public:
    bool getPixelRemap(tMatrixPixelsCoord src_x, tMatrixPixelsCoord src_y, tMatrixPixelsCoord & dst_x, tMatrixPixelsCoord & dst_y) const override {
        if (!matrixSource) {
            return false;
        }

        // Calculate linear index from 2D coordinates (row-major order), index starts from 1
        const uint32_t linearIndex = (src_y * matrixSource->width() + src_x) + 1;
        if (linearIndex == 0) {
            return false; // Skip pixel
        }
        dst_x = to_coord(linearIndex - 1);
        dst_y = 0;
        return true;
    }

    void paramChanged(uint8_t paramNum) override {
        // Validate matrix size when matrix or matrixSource changes
        if (paramNum == csRenderMatrixBase::paramMatrixDest || 
            paramNum == csRenderMatrixPipeBase::paramMatrixSource) {
            if (matrix != nullptr && matrixSource != nullptr) {
                // If size is incorrect, disable effect by setting matrix to nullptr
                if ((matrix->height() != 1) || 
                    (matrix->width() != matrixSource->height() * matrixSource->width())) {
                    matrix = nullptr;
                }
            }
        }

        csRenderRemapBase::paramChanged(paramNum);
    }
};
    
// Effect: convert 2D matrix to linear 1D matrix (height=1, width=src.height*src.width).
// Index mode with custom index mapping via matrixIndex.
//
// `csRenderMatrixCopyLineIndex` contains the matrix `matrixIndex`.
// It is desirable that its size matches `matrixSource`.
// But this is not required.
//
// `csRenderMatrixCopyLineIndex` copies pixels from `matrixSource` to `matrixDest`.
// For this, it takes the pixel `(x, y)`, then takes the number from `matrixIndex`,
// and writes to `matrixDest` at coordinates `(matrixIndex, 0)`.
// Thus, the matrix `matrixIndex` is a table where each number is the index
// in the linear matrix where the corresponding pixel should be placed.
class csRenderMatrixCopyLineIndex : public csRenderMatrix2DTo1D {
public:
    static constexpr uint8_t base = csRenderMatrixPipeBase::paramLast;
    static constexpr uint8_t paramMatrixIndex = base + 1;
    static constexpr uint8_t paramLast = paramMatrixIndex;

    // Index matrix pointer (nullptr means use default index calculation).
    csMatrixPixels* matrixIndex = nullptr;

    uint8_t getParamsCount() const override {
        return paramLast;
    }

    void getParamInfo(uint8_t paramNum, csParamInfo& info) override {
        csRenderMatrix2DTo1D::getParamInfo(paramNum, info);
        switch (paramNum) {
            case paramMatrixIndex:
                info.type = ParamType::Matrix;
                info.name = "Matrix index";
                info.ptr = &matrixIndex;
                info.readOnly = false;
                info.disabled = false;
                break;
        }
    }

    bool getPixelRemap(tMatrixPixelsCoord src_x, tMatrixPixelsCoord src_y, tMatrixPixelsCoord & dst_x, tMatrixPixelsCoord & dst_y) const override {
        if (!matrixSource || !matrixIndex) {
            return false;
        }

        uint32_t linearIndex = matrixIndex->getPixel(src_x, src_y).value;
        
        if (linearIndex == 0) {
            return false; // Skip pixel
        }

        dst_x = to_coord(linearIndex - 1);
        dst_y = 0;
        return true;
    }
};

} // namespace amp
